<?php
namespace Sfynx\CoreBundle\Generator\Domain\Component\File;

use SplSubject;
use SplObserver;
use stdClass;
use Nette\PhpGenerator\Helpers;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\Method;
use Sfynx\CoreBundle\Generator\Domain\Templater\Generalisation\Interfaces\TemplaterInterface;
use Sfynx\CoreBundle\Generator\Domain\Component\File\HandlerModel\Observer\FormData;
use Sfynx\CoreBundle\Generator\Domain\Report\Generalisation\AbstractGenerator;

/**
 * File finder
 * @category   Sfynx\CoreBundle\Generator
 * @package    Domain
 * @subpackage Component\File
 *
 * @author Etienne de Longeaux <etienne.delongeaux@gmail.com>
 */
class ClassHandler implements SplSubject
{
    /** @var \SplObserver[] */
    protected $observers = [];

    /** @var stdClass */
    public $event;

    /** @var array */
    public static $constructorArguments = [];
    /** @var array */
    public static $classMethods = [];

    /** @var string */
    const TYPE_ENTITY = 'id';
    const TYPE_VO = 'valueObject';
    const TYPE_UUID = 'uuid';
    const TYPE_INTEGER = 'integer';
    const TYPE_NUMBER = 'number';
    const TYPE_BOOLEAN = 'boolean';
    const TYPE_ARRAY = 'array';
    const TYPE_TEXT = 'string';
    const TYPE_TEXTAREA = 'textarea';
    const TYPE_EMAIL = 'email';
    const TYPE_DATE = 'datetime';
    const TYPE_SUBMIT = 'submit';

    const ALL_TYPES = [
        self::TYPE_ENTITY,
        self::TYPE_UUID,
        self::TYPE_INTEGER,
        self::TYPE_NUMBER,
        self::TYPE_BOOLEAN,
        self::TYPE_ARRAY,
        self::TYPE_TEXT,
        self::TYPE_TEXTAREA,
        self::TYPE_EMAIL,
        self::TYPE_DATE,
        self::TYPE_SUBMIT,
    ];

    /**
     * @param TemplaterInterface $template
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     */
    public  function __construct(TemplaterInterface $template, PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = [])
    {
        $this->event = new \stdClass();
        $this->event->template = $template;
        $this->event->namespace = $namespace;
        $this->event->class = $class;
        $this->event->data = $data;
        $this->event->index = $index;
    }

    /**
     * {@inheritDoc}
     */
    public function attach(SplObserver $observer)
    {
        $key = \array_search($observer,$this->observers, true);
        if (!$key) {
            $this->observers[] = $observer;
        }
        return $this;
    }

    /**
     * {@inheritDoc}
     */
    public function detach(SplObserver $observer)
    {
        $key = \array_search($observer,$this->observers, true);
        if ($key) {
            unset($this->observers[$key]);
        }
    }

    /**
     * {@inheritDoc}
     */
    public function notify()
    {
        foreach ($this->observers as $observer) {
            $observer->update($this);
        }
    }

    /**
     * @inheritdoc
     */
    public static function getDirenameFromNamespace(string $namespace): string
    {
        if (\strrpos($namespace, '\\')) {
            return \substr($namespace, 0, -strlen($namespace) + strrpos($namespace, '\\'));
        }

        return $namespace;
    }

    /**
     * @inheritdoc
     */
    public static function getClassNameFromNamespace(string $namespace): string
    {
        if (\strrpos($namespace, '\\')) {
            return \substr($namespace, strrpos($namespace, '\\') + 1);
        }

        return $namespace;
    }

    /**
     * Return a new instance of a namespace.
     *
     * @param string $namespace
     * @return PhpNamespace
     * @static
     */
    public static function getNamespace(string $namespace): PhpNamespace
    {
        return new PhpNamespace($namespace);
    }

    /**
     * Return a new instance of a class.
     *
     * @param string $class
     * @return ClassType
     * @static
     */
    public static function getClass(string $class): ClassType
    {
        return new ClassType($class);
    }

    /**
     * @param object $class
     * @return string
     * @static
     */
    public static function tabsToSpaces(object $object, int $indentation): string
    {
        return Helpers::tabsToSpaces((string) $object, $indentation);
    }

    /**
     * Get file doc comment
     *
     * @return string
     */
    public static function getFileCommentor(): string
    {
        // We open the buffer.
        \ob_start ();
        ?>
/*
 * This file is generated by SFYNX CORE GENERATOR.
 *
 * (c) Etienne de Longeaux <sfynx@pi-groupe.net>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
        <?php
        // We retrieve the contents of the buffer.
        $_content = \ob_get_contents ();
        // We clean the buffer.
        \ob_clean ();
        // We close the buffer.
        \ob_end_flush ();

        return $_content;
    }

    /**
     * Set documentor of a class.
     *
     * @param ClassType $class
     * @param TemplaterInterface $templater
     * @param stdClass $data
     * @return void
     * @static
     */
    public static function setClassCommentor(ClassType $class, TemplaterInterface $templater, stdClass $data): void
    {
        $package = \ucfirst(\strtolower($templater->getCategory()));

        $class->addComment('Class ' . $templater->getTargetClassname());

        self::addComments($class, $data);

        $class->addComment('');
        $class->addComment('@category ' . $templater->getNamespace());
        $class->addComment('@package ' . $package);
        $class->addComment('@subpackage ' . \str_replace($templater->getNamespace() . '\\' . $package . '\\', '', $templater->getTargetNamespace()));
        $class->addComment('');
        $class->addComment('@author SFYNX <sfynx@pi-groupe.net>');
        $class->addComment('@link http://www.sfynx.org');
        $class->addComment('@license LGPL (https://opensource.org/licenses/LGPL-3.0)');
    }

    /**
     * Add comments in a class documentor.
     *
     * @param ClassType $class
     * @param stdClass $data
     * @return void
     * @static
     */
    public static function addComments(ClassType $class, stdClass $data): void
    {
        if (\property_exists($data, 'comments')
            && !empty($data->comments)
        ) {
            foreach ($data->comments as $comment) {
                $class->addComment($comment);
            }
        }
    }

    /**
     * Set extends value in a class.
     *
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     * @param string $context
     * @return void
     * @static
     */
    public static function setExtends(PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = [], string $context = ''): void
    {
        if (\property_exists($data, 'extends')
            && !empty($data->extends)
        ) {
            $class->setExtends(self::getClassNameFromNamespace($data->extends));
            self::addUse($namespace, $data->extends, $index, $context);
        }
    }

    /**
     * Add multiple uses in a class.
     *
     * @param PhpNamespace $namespace
     * @param stdClass $data
     * @param array|null $index
     * @param string $context
     * @return void
     * @static
     */
    public static function addUses(PhpNamespace $namespace, stdClass $data, ?array $index = [], string $context = ''): void
    {
        if (\property_exists($data, 'options')
            && \property_exists($data->options, 'uses')
            && !empty($data->options->uses)
        ) {
            foreach ($data->options->uses as $use) {
                self::addUse($namespace, $use, $index, $context);
            }
        }
    }

    /**
     * Add use in a class.
     *
     * @param PhpNamespace $namespace
     * @param string $use
     * @param array|null $index
     * @param string $context
     * @return void
     * @static
     */
    public static function addUse(PhpNamespace $namespace, string $use, ?array $index = [], string $context = ''): void
    {
        if (!empty($index)) {
            foreach ($index as $class => $arguments) {
                \str_replace($use, $use, $class, $count);
                if ($count
                    && (self::getClassNameFromNamespace($use) == self::getClassNameFromNamespace($class))
                ) {
                    $use = $class;
                }
            }
        }
        \str_replace('$', '$', $use, $countVar);
        if (0 == $countVar) {
            \str_replace($context, $context, $use, $countContext);
            if (!empty($context) && (0 == $countContext)) {
                $use = $context . '\\' . $use;
            }
            if (!\in_array($use, self::ALL_TYPES)) {
                $namespace->addUse($use);
            }
        }
    }

    /**
     * Add interfaces in a class.
     *
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     * @param string $context
     * @return void
     * @static
     */
    public static function addImplements(PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = [], string $context = ''): void
    {
        if (\property_exists($data, 'options')
            && \property_exists($data->options, 'implements')
            && !empty($data->options->implements)
        ) {
            foreach ($data->options->implements as $implement) {
                $class->addImplement(self::getClassNameFromNamespace($implement));
                self::addUse($namespace, $implement, $index, $context);
            }
        }
    }

    /**
     * Addd traits in a class.
     *
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     * @param string $context
     * @return void
     * @static
     */
    public static function addTraits(PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = [], string $context = ''): void
    {
        if (\property_exists($data, 'options')
            && \property_exists($data->options, 'traits')
            && !empty($data->options->traits)
        ) {
            foreach ($data->options->traits as $trait) {
                $class->addTrait(self::getClassNameFromNamespace($trait));
                self::addUse($namespace, $trait, $index, $context);
            }
        }
    }

    /**
     * Add arguments of the __construct method of a class.
     *
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     * @param string $context
     * @param bool $addConstruct
     * @return void
     * @static
     */
    public static function addArguments(PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = [], string $context = '', bool $addConstruct = true): void
    {
        if (\property_exists($data, 'arguments')
            && !empty($data->arguments)
        ) {
            foreach ($data->arguments as $argument) {
                self::addUse($namespace, $argument, $index, $context);
                $info = self::getArgResult($namespace, $argument, [], false);

                if (\property_exists($data, 'construct') && !empty($data->construct)
                    && \property_exists($data->construct, 'create') && ($data->construct->create == true)
//                    && \property_exists($data->construct, 'body')
//                    && !empty($data->construct->body)
                ) {
                    if (\in_array($info['type'], ['interface', 'class'])) {
                        self::setArgClassResult($namespace, $argument, $index, $info['value'], $info['basename'], $addConstruct);
                    } elseif ($addConstruct && \in_array($info['type'], ['var'])) {
                        self::addConstructorArgument($info['argument'], $info);
                    } elseif ($addConstruct && \in_array($info['type'], ['bool'])) {
                        self::setArgClassResult($namespace, $argument, $index, $info['argument'], $info['type'], $addConstruct);
                    }
                }
            }
        }
    }

    /**
     * Create multiple methods in a class.
     *
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     * @return void
     * @static
     */
    public static function createMethods(PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = []): void
    {
        if (\property_exists($data, 'options')
            && \property_exists($data->options, 'methods')
            && !empty($data->options->methods)
        ) {
            foreach ($data->options->methods as $name => $method) {
                if (\property_exists($method, 'name')) {
                    // set default values
                    $methodArgs = '';
                    $body = '';
                    $countInheritdoc = 0;

                    // create method
                    $methodClass = $class->addMethod($method->name);

                    // set Method values
                    if (\property_exists($method, 'visibility') && !empty($method->visibility)) {
                        $methodClass->setVisibility($method->visibility);
                    }
                    if (\property_exists($method, 'static') && true == $method->static) {
                        $methodClass->setStatic($method->static);
                    }
                    if (\property_exists($method, 'comments') && !empty($method->comments)) {
                        foreach ($method->comments as $comment) {
                            \str_replace('inheritdoc', 'inheritdoc', $comment, $countInheritdoc);
                            $methodClass->addComment($comment);
                        }
                    }
                    if (\property_exists($method, 'arguments') && !empty($method->arguments)) {
                        $methodArgs = self::setArgs($namespace, $method->arguments, $index, false);

                        foreach ($method->arguments as $argument) {
                            $info = self::getArgResult($namespace, $argument, [], false);
                            $type = $info['type'];
                            $arg = $info['value'];
                            $defaultValue = '';

                            if ('interface' == $type) {
                                $methodClass->addParameter($arg)->setTypeHint($info['basename']);
                            }

                            $newArgument = \trim(\str_replace(' $', ' ', \trim($argument), $countSpace));
                            if (1 == $countSpace) {
                                $info = \explode(' ', $newArgument);
                                $type = $info[0];
                                $arg = $info[1];

                                \str_replace('=', ' ', \trim($argument), $countDefaultValue);
                                if (1 == $countDefaultValue) {
                                    $defaultValue = \end($info);
                                    $defaultValue = ($defaultValue === 'false') ? false : $defaultValue;
                                    $defaultValue = ($defaultValue === 'true') ? true : $defaultValue;
                                    $defaultValue = ($defaultValue === '[]') ? [] : $defaultValue;
                                    $defaultValue = ($defaultValue === 'null') ? null : $defaultValue;
                                    $defaultValue = \is_numeric($defaultValue) ? \intval($defaultValue) : $defaultValue;
                                    $methodClass->addParameter($arg)->setTypeHint($type)->setDefaultValue($defaultValue);
                                } else {
                                    $methodClass->addParameter($arg)->setTypeHint($type);
                                }
                            } else {
                                $newArgument = \str_replace('$', '', \trim($argument), $count);
                                if (1 == $count) {
                                    $methodClass->addParameter($newArgument);
                                }
                            }
                            // add phpdocumentor argument value
                            $commentDefaultValue = \is_null($defaultValue) ? '|null' : '';
                            $methodClass->addComment(sprintf('@param %s%s $%s', $type, $commentDefaultValue, $arg));
                        }
                    }
                    if (\property_exists($method, 'returnType')  && !empty($method->returnType)) {
                        $info = self::getArgResult($namespace, $method->returnType, [], false);
                        $methodClass->setReturnType($info['basename']);

                        if (0 == $countInheritdoc) {
                            $methodClass->addComment(sprintf('@return %s', $info['basename']));
                        }
                    }

                    // set Body of the method
                    if (\property_exists($method, 'body') && !empty($method->body)) {
                        foreach ($method->body as $line) {
                            $body .= $line . PHP_EOL;
                        }
                    }
                    if (\property_exists($method, 'returnParent') && !empty($method->returnParent)) {
                        $body .= "return parent::$method->name($methodArgs);" . PHP_EOL;
                    }
                    if (\property_exists($method, 'insertParent') && !empty($method->insertParent)) {
                        $body .= "parent::$method->name($methodArgs);" . PHP_EOL;
                    }

                    $methodClass->addBody($body);

                    self::$classMethods[] = $methodClass;
                }
            }
        }
    }

    /**
     * @param ClassType $class
     * @return void
     * @static
     */
    public static function addMethods(ClassType $class): void
    {
        // we sort in the opposite direction
        krsort(self::$classMethods);
        // we replace methods with the new order
        $class->setMethods(self::$classMethods);
        // we initialize methods tab
        self::$classMethods = [];
    }

    /**
     * @param TemplaterInterface $template
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @param array|null $index
     * @return void
     * @static
     */
    public static function addModels(TemplaterInterface $template, PhpNamespace $namespace, ClassType $class, stdClass $data, ?array $index = []): void
    {
        if (\property_exists($data, 'options')
            && \property_exists($data->options, 'models')
            && !empty($data->options->models)
        ) {
            $obsModel = new self($template, $namespace, $class, $data, $index);
            foreach ($data->options->models as $model) {
                if (\is_string($model)) {
                    $obsModel->attach(new $model());
                } elseif (\property_exists($model, 'class')) {
                    $class = $model->class;
                    if (\property_exists($model, 'parameters')) {
                        $arrayParameters = AbstractGenerator::transform($model->parameters, true);
                        $obsModel->attach(new $class($arrayParameters));
                    } else {
                        $obsModel->attach(new $class());
                    }
                }
            }
            $obsModel->notify();
        }
    }

    /**
     * @param string $interfaceName
     * @param string|array $attributeName
     * @return void
     */
    public static function addConstructorArgument(string $interfaceName, $attributeName): void
    {
        self::$constructorArguments[$interfaceName] = $attributeName;
    }

    /**
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @param stdClass $data
     * @return Method|null
     * @static
     */
    public static function addConstructorMethod(PhpNamespace $namespace, ClassType $class, stdClass $data = null): ?Method
    {
        if (!empty(self::$constructorArguments)) {
            $method = $class->addMethod('__construct')
                ->addComment(sprintf('%s constructor.', $class->getName()))
                ->addComment('');

            $body = '';

            foreach (self::$constructorArguments as $value => $attribute) {
                $defaultValue = 'no';

                if (\is_array($attribute) && isset($attribute['basename'])) {
                    $value = \preg_replace('!\s+!', ' ', $attribute['basename']);
                    list($type, $arg) = \explode(' ', $value);

                    \str_replace('=', '=', $value, $countEgual);
                    if (1 == $countEgual) {
                        list($content, $defaultValue) = explode('=', $value);
                        $defaultValue = \trim($defaultValue);
                        $defaultValue = ($defaultValue == "false") ? false : $defaultValue;
                        $defaultValue = ($defaultValue == "true") ? true : $defaultValue;
                        $defaultValue = ($defaultValue === '[]') ? [] : $defaultValue;
                        $defaultValue = ($defaultValue === 'null') ? null : $defaultValue;
                        $defaultValue = \is_numeric($defaultValue) ? \intval($defaultValue) : $defaultValue;
                    }
                } elseif ('bool' == $value) {
                    $arg = \lcfirst(\str_replace('$this->', '', $attribute));
                    $type = $value;
                    $body .= "$attribute = \$$arg;" . PHP_EOL;
                } else {
                    $arg = \lcfirst(\str_replace('Interface', '', $value));
                    $type = $value;
                    $body .= "$attribute = \$$arg;" . PHP_EOL;
                }
                $type = \trim($type);
                $value = \trim($value);
                $arg = \trim(\str_replace('$', '', $arg));

                $Parameter = $method->addParameter($arg)->setTypeHint($type);
                if ('no' !== $defaultValue) {
                    $Parameter->setDefaultValue($defaultValue);
                }
                // add phpdocumentor argument value
                $commentDefaultValue = \is_null($defaultValue) ? '|null' : '';
                $method->addComment(sprintf('@param %s%s $%s', $type, $commentDefaultValue, $arg));

                $class->addProperty($arg)->setComment(sprintf('@var %s', $type))->setVisibility('protected');
            }
            self::$constructorArguments = [];

            if (!\is_null($data)
                && \property_exists($data, 'construct') && !empty($data->construct)
                && \property_exists($data->construct, 'create') && ($data->construct->create == true)
                && \property_exists($data->construct, 'body')
                && !empty($data->construct->body)
            ) {
                $body .= PHP_EOL;
                foreach ($data->construct->body as $line) {
                    $body .= $line . PHP_EOL;
                }
            }
            $method->addBody($body);

            self::$classMethods[] = $method;

            return  $method;
        }

        return null;
    }

    /**
     * @param PhpNamespace $namespace
     * @param ClassType $class
     * @return Method
     * @static
     */
    public static function addCoordinationMethod(PhpNamespace $namespace, ClassType $class): Method
    {
        $namespace->addUse('Symfony\Component\HttpFoundation\Response');

        return $class->addMethod('coordinate')->addComment('@return Response');
    }

    /**
     * @param PhpNamespace $namespace
     * @param array $arguments
     * @param array|null $index
     * @param bool $addConstruct
     * @param int $test
     * @return string
     */
    public static function setArgs(PhpNamespace $namespace, array $arguments, ?array $index = [], bool $addConstruct = true, string $infoKey = 'argument', int $test = 0): string
    {
        $result = [];

        if (!empty($arguments)) {
            foreach ($arguments as $argument) {
                $info = self::getArgResult($namespace, $argument, $index, $addConstruct, $test);
                $result[] = $info[$infoKey];
            }
        }

        return \implode(', ', $result);
    }

    /**
     * @param PhpNamespace $namespace
     * @param string $argument
     * @param array|null $index
     * @param bool $addConstruct
     * @param int $test
     * @return array
     */
    public static function getArgResult(PhpNamespace $namespace, string $argument, ?array $index = [], bool $addConstruct = true, int $test = 0): array
    {
        $argument = \trim(preg_replace('!\s+!', ' ', $argument));

        $basename = ClassHandler::getClassNameFromNamespace($argument);
        $argResult = $argument;
        $type = 'default';
        $value = $argument;

        \str_replace(',', ',', $argument, $countArray);
        if (1 <= $countArray) {
            $type = 'array';

            // obtain all patterns in parentheses delimited with a comma
            preg_match_all("/[^\s,[\]]*/", $value, $matches, PREG_PATTERN_ORDER);
            $arguments = array_filter($matches[0]);

            // for all pattern, search the argument value if the pattern is a namespace
            $argResult = [];
            foreach ($arguments as $arg) {
                $info = self::getArgResult($namespace, $arg, $index, $addConstruct, $test);
                $argResult[] = $info['argument'];
            }

            // we recreate the value
            $argResult = '[' . implode(', ', $argResult) . ']';

            return ['argument' => $argResult, 'basename' => $basename, 'type' => $type, 'value' => $value];
        }

        $className = \trim(str_replace('new', '', $argument, $countNew));
        if (1 == $countNew) {
            $argResult = self::setArgNewResult($namespace, $argument, $index, $className, $addConstruct, $test);
            $type = 'new';
            $value = $className;
        }

        $interfaceName = \lcfirst(str_replace('Interface', '', $basename, $countInterface));
        if (1 == $countInterface) {
            $argResult = self::setArgClassResult($namespace, $argument, $index, $interfaceName, $basename, $addConstruct);
            $type = 'interface';
            $value = $interfaceName;
        }

        $asClassArgument = \str_replace(' as ', ' as ', $argument, $countAs);
        if ((1 <= $countAs) && (0 == $countInterface)) {
            list($content, $defaultValue) = \explode(' as ', $argument);
            $type = 'class';
            $value = $defaultValue;
            $basename = $defaultValue;
            $argResult = self::setArgClassResult($namespace, $argument, $index, \trim($value), $basename, $addConstruct);
        }

        $classArgument = \str_replace('\\', '\\', $argument, $countArg);
        if ((0 == $countAs) && (1 <= $countArg) && (0 == $countInterface)) {
            $argResult = self::setArgClassResult($namespace, $argument, $index, $basename, $basename, $addConstruct);
            $type = 'class';
            $value = $basename;
        }

        $newArgument = \str_replace(' ', ' ', $argument, $countVar);
        \str_replace('=', '=', $argument, $countEgual);
        if ((0 == $countAs) && (1 == $countEgual)) {
            list($content, $defaultValue) = \explode('=', $argument);
            $argResult = \trim($defaultValue);
            $type = 'var';
            $value = $content;

            if (3 == $countVar) {
                list($type, $argResult, $value) = \explode(' ', $argument);
            }
        } elseif ((0 == $countAs) && (1 <= $countVar) && (0 == $countNew)) {
            $argResult = self::setArgVarResult($newArgument);
            $type = 'var';
            $value = $newArgument;
        }

        return ['argument' => $argResult, 'basename' => $basename, 'type' => $type, 'value' => $value];
    }

    /**
     * @param PhpNamespace $namespace
     * @param string $argument
     * @param array|null $index
     * @param string $className
     * @param bool $addConstruct
     * @param int $test
     * @return string
     */
    public static function setArgNewResult(PhpNamespace $namespace, string $argument, ?array $index = [], string $className, bool $addConstruct = true, int $test = 0): string
    {
        $newArgs = null;
        foreach ($index as $class => $args) {
            $namespaceClass = self::getClassNameFromNamespace($class);

            if ($namespaceClass == $className
                && !empty($args)
            ) {
                foreach ($args as $arg) {
                    $info = self::getArgResult($namespace, $arg, $index, $addConstruct, 2);
                    $newArgs[] = $info['argument'];
                }
                $newArgs = \implode(', ', $newArgs);
            }
        }
        self::addUse($namespace, $className, $index);

        return "$argument($newArgs)";
    }

    /**
     * @param PhpNamespace $namespace
     * @param string $argument
     * @param array|null $index
     * @param string $value
     * @param string $basename
     * @param bool $addConstruct
     * @return string
     */
    public static function setArgClassResult(
            PhpNamespace $namespace,
            string $argument,
            ?array $index = [],
            string $value,
            string $basename,
            bool $addConstruct = true
    ): string {
        self::addUse($namespace, $argument, $index);

        $value = \lcfirst(str_replace('$', '', $value));
        $attribute = "\$$value";
        if ($addConstruct) {
            $attribute = "\$this->$value";
            self::addConstructorArgument($basename, $attribute);
        }

        return "$attribute";
    }

    /**
     * @param string $argument
     * @return string
     */
    public static function setArgVarResult(string $argument): string
    {
        list($type, $arg) = \explode(' ', $argument);

        return $arg;
    }

    /**
     * @param TemplaterInterface $templater
     * @param stdClass $data
     * @return string
     * @static
     */
    public static function createNamespaceEntity(TemplaterInterface $templater, string $entityName): string
    {
        if (!\strrpos($entityName, '\\')) {
            $entityName = \sprintf('%s\%s', $templater->namespace, 'Domain\\Service\\Entity\\' . $entityName);
        }

        return $entityName;
    }

    /**
     * Return the field type value.
     *
     * @param string $type
     * @param stdClass|null $field
     * @static
     * @return mixed
     */
    public static function getType(string $type, stdClass $field = null, bool $withTargetEntity = false)
    {
        if ($withTargetEntity
            && !\is_null($field)
            && \property_exists($field, 'mapping')
            && \property_exists($field->mapping, 'targetEntity')
        ) {
            $type = $field->mapping->targetEntity;
        }

        switch ($type) {
            case self::TYPE_VO:
                $newType = 'Sfynx\CoreBundle\Layers\Domain\ValueObject\Generalisation\Interfaces\ValueObjectInterface';
                break;
            case self::TYPE_ENTITY:
                $newType = 'int';
                break;
            case self::TYPE_UUID:
                $newType = 'string';
                break;
            case self::TYPE_INTEGER:
                $newType = 'int';
                break;
            case self::TYPE_NUMBER:
                $newType = 'int';
                break;
            case self::TYPE_BOOLEAN:
                $newType = 'bool';
                break;
            case self::TYPE_TEXTAREA:
                $newType = 'string';
                break;
            case self::TYPE_EMAIL:
                $newType = 'string';
                break;
            case self::TYPE_DATE:
                $newType = 'DateTime';
                break;
            case self::TYPE_ARRAY:
                $newType = 'array';
                if (!\is_null($field)
                    && \property_exists($field, 'multiple')
                    && !$field->multiple
                ) {
                    $newType = 'int';
                }
                break;
            default:
                $newType = $type;
        }

        return $newType;
    }

    /**
     * @param stdClass $field
     * @return string
     */
    public static function getValue(stdClass $field, string $defaultBoolValue = 'true')
    {
        // set default value
        $value = 'null';
        if (self::getType($field->type) == 'bool') {
            $value =  $defaultBoolValue;
        }
        // set default value if specify in field
        if (\property_exists($field, 'defaultValue')) {
            $value =  $field->defaultValue;
        }

        if (\is_bool($value)) {
            $value = (int)$value ? 'true' : 'false';
        }
        if ($value !== 'null'
            && self::getType($field->type) !== 'bool'
            && \is_string($value)
        ) {
            $value = "'$value'";
        }

        return $value;
    }

    /**
     * Return true if the string value is composed inside with the 'int' or 'id' pattern.
     *
     * @param string $value
     * @static
     * @return bool
     */
    public static function isIntType(string $value)
    {
        if ((\strpos(\strtolower($value), 'int') !== false)
            || (\strpos(\strtolower($value), 'id') !== false)
        ) {
            return true;
        }
        return false;
    }

    /**
     * Return true if the string value is composed inside with the 'date' pattern.
     *
     * @param string $value
     * @static
     * @return bool
     */
    public static function isDateType(string $value)
    {
        if (\strpos(\strtolower($value), 'date') !== false) {
            return true;
        }
        return false;
    }

    /**
     * Convert a php array to a string array
     *
     * @param array $args
     * @param string $result
     * @static
     * @return string
     */
    public static function recursiveArrayToString(array $args = [], string $result = '', string $tab = '            ')
    {
        $result .= '[';
        foreach ($args as $k => $value) {
            \str_replace('$', '$', $value, $countVar);
            $value = \is_string($value) && (0 == $countVar) ? "'$value'" : $value;
            $value = \is_array($value) ? self::recursiveArrayToString($value, '', $tab . '    '): $value;

            $k = \is_string($k) ? "'$k'" : $k;

            $result .= PHP_EOL . $tab . "$k => " . $value . ', ';
        }
        if (!empty($args)) {
            $result .= PHP_EOL . substr($tab, 0, -4) . ']';
        } else {
            $result .=  ']';
        }

        return $result;
    }
}